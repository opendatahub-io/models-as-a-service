/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package maas

import (
	"context"
	"testing"

	maasv1alpha1 "github.com/opendatahub-io/models-as-a-service/maas-controller/api/maas/v1alpha1"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	apimeta "k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/types"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client/fake"
	gatewayapiv1 "sigs.k8s.io/gateway-api/apis/v1"
)

// authPolicyTestRESTMapper builds a REST mapper that covers all GVKs exercised in
// these tests, including the Kuadrant AuthPolicy which is not registered in the scheme.
func authPolicyTestRESTMapper() apimeta.RESTMapper {
	m := apimeta.NewDefaultRESTMapper(nil)
	ns := nsRestScope{}
	m.Add(schema.GroupVersionKind{Group: "maas.opendatahub.io", Version: "v1alpha1", Kind: "MaaSModel"}, ns)
	m.Add(schema.GroupVersionKind{Group: "maas.opendatahub.io", Version: "v1alpha1", Kind: "MaaSAuthPolicy"}, ns)
	m.Add(schema.GroupVersionKind{Group: "gateway.networking.k8s.io", Version: "v1", Kind: "HTTPRoute"}, ns)
	m.Add(schema.GroupVersionKind{Group: "kuadrant.io", Version: "v1", Kind: "AuthPolicy"}, ns)
	m.Add(schema.GroupVersionKind{Group: "kuadrant.io", Version: "v1", Kind: "AuthPolicyList"}, ns)
	return m
}

// newPreexistingAuthPolicy builds a Kuadrant AuthPolicy as an unstructured object
// with a sentinel value in spec.targetRef.name. Tests use this to detect whether
// the controller overwrote the spec or left it untouched.
func newPreexistingAuthPolicy(name, namespace, modelName string, annotations map[string]string) *unstructured.Unstructured {
	ap := &unstructured.Unstructured{}
	ap.SetGroupVersionKind(schema.GroupVersionKind{Group: "kuadrant.io", Version: "v1", Kind: "AuthPolicy"})
	ap.SetName(name)
	ap.SetNamespace(namespace)
	ap.SetLabels(map[string]string{
		"maas.opendatahub.io/model":    modelName,
		"app.kubernetes.io/managed-by": "maas-controller",
		"app.kubernetes.io/part-of":    "maas-auth-policy",
		"app.kubernetes.io/component":  "auth-policy",
	})
	ap.SetAnnotations(annotations)
	_ = unstructured.SetNestedField(ap.Object, "sentinel-route", "spec", "targetRef", "name")
	return ap
}

// TestMaaSAuthPolicyReconciler_ManagedAnnotation verifies the opt-out behaviour of the
// "opendatahub.io/managed" annotation on generated Kuadrant AuthPolicy resources.
//
// When the annotation is set to "false" on an existing AuthPolicy, the controller must
// leave the resource untouched. Any other value (or the annotation being absent) means
// the controller owns the resource and must overwrite its spec.
func TestMaaSAuthPolicyReconciler_ManagedAnnotation(t *testing.T) {
	const (
		modelName      = "llm"
		namespace      = "default"
		httpRouteName  = "maas-model-" + modelName // ExternalModel naming convention
		authPolicyName = "maas-auth-" + modelName  // generated by the controller
		maasPolicyName = "policy-a"
	)

	// Shared objects used during reconciliation – recreated fresh per sub-test via WithObjects.
	model := &maasv1alpha1.MaaSModel{
		ObjectMeta: metav1.ObjectMeta{Name: modelName, Namespace: namespace},
		Spec: maasv1alpha1.MaaSModelSpec{
			ModelRef: maasv1alpha1.ModelReference{Kind: "ExternalModel", Name: modelName},
		},
	}
	route := &gatewayapiv1.HTTPRoute{
		ObjectMeta: metav1.ObjectMeta{Name: httpRouteName, Namespace: namespace},
	}
	maasPolicy := &maasv1alpha1.MaaSAuthPolicy{
		ObjectMeta: metav1.ObjectMeta{Name: maasPolicyName, Namespace: namespace},
		Spec: maasv1alpha1.MaaSAuthPolicySpec{
			ModelRefs: []string{modelName},
			Subjects:  maasv1alpha1.SubjectSpec{Groups: []maasv1alpha1.GroupReference{{Name: "team-a"}}},
		},
	}

	tests := []struct {
		name            string
		annotations     map[string]string
		wantSpecChanged bool // true → controller should overwrite spec; false → must leave it alone
	}{
		{
			name:            "annotation absent: controller overwrites spec",
			annotations:     map[string]string{},
			wantSpecChanged: true,
		},
		{
			name:            "managed=false: controller skips update (opt-out)",
			annotations:     map[string]string{ManagedByODHOperator: "false"},
			wantSpecChanged: false,
		},
		{
			name:            "managed=true: controller overwrites spec",
			annotations:     map[string]string{ManagedByODHOperator: "true"},
			wantSpecChanged: true,
		},
		{
			name:            "managed=false: controller skips update (opt-out)",
			annotations:     map[string]string{ManagedByMaasODHOperator: "false"},
			wantSpecChanged: false,
		},
		{
			name:            "managed=true: controller overwrites spec",
			annotations:     map[string]string{ManagedByMaasODHOperator: "true"},
			wantSpecChanged: true,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			// Pre-populate the store with a generated AuthPolicy whose spec contains a
			// sentinel targetRef. After reconciliation we check whether it changed.
			existingAP := newPreexistingAuthPolicy(authPolicyName, namespace, modelName, tc.annotations)

			c := fake.NewClientBuilder().
				WithScheme(scheme).
				WithRESTMapper(authPolicyTestRESTMapper()).
				WithObjects(model, route, maasPolicy, existingAP).
				WithStatusSubresource(&maasv1alpha1.MaaSAuthPolicy{}).
				Build()

			r := &MaaSAuthPolicyReconciler{Client: c, Scheme: scheme}
			req := ctrl.Request{NamespacedName: types.NamespacedName{Name: maasPolicyName, Namespace: namespace}}
			if _, err := r.Reconcile(context.Background(), req); err != nil {
				t.Fatalf("Reconcile: unexpected error: %v", err)
			}

			got := &unstructured.Unstructured{}
			got.SetGroupVersionKind(schema.GroupVersionKind{Group: "kuadrant.io", Version: "v1", Kind: "AuthPolicy"})
			if err := c.Get(context.Background(), types.NamespacedName{Name: authPolicyName, Namespace: namespace}, got); err != nil {
				t.Fatalf("Get AuthPolicy %q: %v", authPolicyName, err)
			}

			// The controller sets spec.targetRef.name to the HTTPRoute name on update.
			// A sentinel value means no update occurred.
			targetRefName, _, _ := unstructured.NestedString(got.Object, "spec", "targetRef", "name")
			specChanged := targetRefName != "sentinel-route"

			if specChanged != tc.wantSpecChanged {
				if tc.wantSpecChanged {
					t.Errorf("spec.targetRef.name = %q: expected controller to overwrite sentinel value %q", targetRefName, "sentinel-route")
				} else {
					t.Errorf("spec.targetRef.name = %q: expected controller to preserve sentinel value %q (managed=false opt-out)", targetRefName, "sentinel-route")
				}
			}
		})
	}
}

// TestMaaSAuthPolicyReconciler_DeleteAnnotation verifies that the Reconcile deletion
// path respects the opt-out annotation: an AuthPolicy with opendatahub.io/managed=false
// or maas.opendatahub.io/managed=false must not be deleted when the parent
// MaaSAuthPolicy is removed.
func TestMaaSAuthPolicyReconciler_DeleteAnnotation(t *testing.T) {
	const (
		modelName      = "llm"
		namespace      = "default"
		authPolicyName = "maas-auth-" + modelName
		maasPolicyName = "policy-a"
	)

	tests := []struct {
		name        string
		annotations map[string]string
		wantDeleted bool
	}{
		{
			name:        "annotation absent: controller deletes",
			annotations: map[string]string{},
			wantDeleted: true,
		},
		{
			name:        "managed=true (new annotation): controller deletes",
			annotations: map[string]string{ManagedByODHOperator: "true"},
			wantDeleted: true,
		},
		{
			name:        "managed=false (new annotation): controller must not delete",
			annotations: map[string]string{ManagedByODHOperator: "false"},
			wantDeleted: false,
		},
		{
			name:        "managed=true (legacy annotation): controller deletes",
			annotations: map[string]string{ManagedByMaasODHOperator: "true"},
			wantDeleted: true,
		},
		{
			name:        "managed=false (legacy annotation): controller must not delete",
			annotations: map[string]string{ManagedByMaasODHOperator: "false"},
			wantDeleted: false,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			existingAP := newPreexistingAuthPolicy(authPolicyName, namespace, modelName, tc.annotations)

			// Create MaaSAuthPolicy with finalizer so handleDeletion processes it.
			maasPolicy := &maasv1alpha1.MaaSAuthPolicy{
				ObjectMeta: metav1.ObjectMeta{
					Name:       maasPolicyName,
					Namespace:  namespace,
					Finalizers: []string{maasAuthPolicyFinalizer},
				},
				Spec: maasv1alpha1.MaaSAuthPolicySpec{
					ModelRefs: []string{modelName},
					Subjects:  maasv1alpha1.SubjectSpec{Groups: []maasv1alpha1.GroupReference{{Name: "team-a"}}},
				},
			}

			c := fake.NewClientBuilder().
				WithScheme(scheme).
				WithRESTMapper(authPolicyTestRESTMapper()).
				WithObjects(maasPolicy, existingAP).
				Build()

			// Simulate deletion: the fake client sets DeletionTimestamp while the
			// finalizer keeps the object in the store.
			if err := c.Delete(context.Background(), maasPolicy); err != nil {
				t.Fatalf("Delete MaaSAuthPolicy: %v", err)
			}

			r := &MaaSAuthPolicyReconciler{Client: c, Scheme: scheme}
			req := ctrl.Request{NamespacedName: types.NamespacedName{Name: maasPolicyName, Namespace: namespace}}
			if _, err := r.Reconcile(context.Background(), req); err != nil {
				t.Fatalf("Reconcile: unexpected error: %v", err)
			}

			got := &unstructured.Unstructured{}
			got.SetGroupVersionKind(schema.GroupVersionKind{Group: "kuadrant.io", Version: "v1", Kind: "AuthPolicy"})
			err := c.Get(context.Background(), types.NamespacedName{Name: authPolicyName, Namespace: namespace}, got)

			if tc.wantDeleted {
				if !apierrors.IsNotFound(err) {
					t.Errorf("expected AuthPolicy %q to be deleted, but it still exists", authPolicyName)
				}
			} else {
				if err != nil {
					t.Errorf("expected AuthPolicy %q to survive deletion (managed=false opt-out), but got: %v", authPolicyName, err)
				}
			}
		})
	}
}
