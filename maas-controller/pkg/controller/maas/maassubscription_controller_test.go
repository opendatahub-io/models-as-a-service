/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package maas

import (
	"context"
	"testing"

	maasv1alpha1 "github.com/opendatahub-io/models-as-a-service/maas-controller/api/maas/v1alpha1"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	apimeta "k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/types"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client/fake"
	gatewayapiv1 "sigs.k8s.io/gateway-api/apis/v1"
)

// trlpTestRESTMapper builds a REST mapper that covers all GVKs exercised in
// subscription tests, including the Kuadrant TokenRateLimitPolicy which is not
// registered in the scheme.
func trlpTestRESTMapper() apimeta.RESTMapper {
	m := apimeta.NewDefaultRESTMapper(nil)
	ns := nsRestScope{}
	m.Add(schema.GroupVersionKind{Group: "maas.opendatahub.io", Version: "v1alpha1", Kind: "MaaSModel"}, ns)
	m.Add(schema.GroupVersionKind{Group: "maas.opendatahub.io", Version: "v1alpha1", Kind: "MaaSSubscription"}, ns)
	m.Add(schema.GroupVersionKind{Group: "gateway.networking.k8s.io", Version: "v1", Kind: "HTTPRoute"}, ns)
	m.Add(schema.GroupVersionKind{Group: "kuadrant.io", Version: "v1alpha1", Kind: "TokenRateLimitPolicy"}, ns)
	m.Add(schema.GroupVersionKind{Group: "kuadrant.io", Version: "v1alpha1", Kind: "TokenRateLimitPolicyList"}, ns)
	return m
}

// newPreexistingTRLP builds a Kuadrant TokenRateLimitPolicy as an unstructured object
// with a sentinel value in spec.targetRef.name. Tests use this to detect whether
// the controller overwrote the spec or left it untouched.
func newPreexistingTRLP(name, namespace, modelName string, annotations map[string]string) *unstructured.Unstructured {
	p := &unstructured.Unstructured{}
	p.SetGroupVersionKind(schema.GroupVersionKind{Group: "kuadrant.io", Version: "v1alpha1", Kind: "TokenRateLimitPolicy"})
	p.SetName(name)
	p.SetNamespace(namespace)
	p.SetLabels(map[string]string{
		"maas.opendatahub.io/model":    modelName,
		"app.kubernetes.io/managed-by": "maas-controller",
		"app.kubernetes.io/part-of":    "maas-subscription",
		"app.kubernetes.io/component":  "token-rate-limit-policy",
	})
	p.SetAnnotations(annotations)
	_ = unstructured.SetNestedField(p.Object, "sentinel-route", "spec", "targetRef", "name")
	return p
}

// TestMaaSSubscriptionReconciler_ManagedAnnotation verifies the opt-out behaviour of the
// "opendatahub.io/managed" annotation on generated Kuadrant TokenRateLimitPolicy resources.
//
// When the annotation is set to "false" on an existing TokenRateLimitPolicy, the controller
// must leave the resource untouched. Any other value (or the annotation being absent) means
// the controller owns the resource and must overwrite its spec.
func TestMaaSSubscriptionReconciler_ManagedAnnotation(t *testing.T) {
	const (
		modelName     = "llm"
		namespace     = "default"
		httpRouteName = "maas-model-" + modelName // ExternalModel naming convention
		trlpName      = "maas-trlp-" + modelName  // generated by the controller
		maasSubName   = "sub-a"
	)

	// Shared objects used during reconciliation – recreated fresh per sub-test via WithObjects.
	model := &maasv1alpha1.MaaSModel{
		ObjectMeta: metav1.ObjectMeta{Name: modelName, Namespace: namespace},
		Spec: maasv1alpha1.MaaSModelSpec{
			ModelRef: maasv1alpha1.ModelReference{Kind: "ExternalModel", Name: modelName},
		},
	}
	route := &gatewayapiv1.HTTPRoute{
		ObjectMeta: metav1.ObjectMeta{Name: httpRouteName, Namespace: namespace},
	}
	// The subscription must have at least one owner group so that the membership
	// check is non-empty and the controller writes a limits entry into the TRLP spec.
	maasSub := &maasv1alpha1.MaaSSubscription{
		ObjectMeta: metav1.ObjectMeta{Name: maasSubName, Namespace: namespace},
		Spec: maasv1alpha1.MaaSSubscriptionSpec{
			Owner: maasv1alpha1.OwnerSpec{
				Groups: []maasv1alpha1.GroupReference{{Name: "team-a"}},
			},
			ModelRefs: []maasv1alpha1.ModelSubscriptionRef{
				{Name: modelName, TokenRateLimits: []maasv1alpha1.TokenRateLimit{{Limit: 100, Window: "1m"}}},
			},
		},
	}

	tests := []struct {
		name            string
		annotations     map[string]string
		wantSpecChanged bool // true → controller should overwrite spec; false → must leave it alone
	}{
		{
			name:            "annotation absent: controller overwrites spec",
			annotations:     map[string]string{},
			wantSpecChanged: true,
		},
		{
			name:            "managed=false: controller skips update (opt-out)",
			annotations:     map[string]string{ManagedByODHOperator: "false"},
			wantSpecChanged: false,
		},
		{
			name:            "managed=true: controller overwrites spec",
			annotations:     map[string]string{ManagedByODHOperator: "true"},
			wantSpecChanged: true,
		},
		{
			name:            "managed=false: controller skips update (opt-out)",
			annotations:     map[string]string{ManagedByMaasODHOperator: "false"},
			wantSpecChanged: false,
		},
		{
			name:            "managed=true: controller overwrites spec",
			annotations:     map[string]string{ManagedByMaasODHOperator: "true"},
			wantSpecChanged: true,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			// Pre-populate the store with a generated TRLP whose spec contains a
			// sentinel targetRef. After reconciliation we check whether it changed.
			existingTRLP := newPreexistingTRLP(trlpName, namespace, modelName, tc.annotations)

			c := fake.NewClientBuilder().
				WithScheme(scheme).
				WithRESTMapper(trlpTestRESTMapper()).
				WithObjects(model, route, maasSub, existingTRLP).
				WithStatusSubresource(&maasv1alpha1.MaaSSubscription{}).
				Build()

			r := &MaaSSubscriptionReconciler{Client: c, Scheme: scheme}
			req := ctrl.Request{NamespacedName: types.NamespacedName{Name: maasSubName, Namespace: namespace}}
			if _, err := r.Reconcile(context.Background(), req); err != nil {
				t.Fatalf("Reconcile: unexpected error: %v", err)
			}

			got := &unstructured.Unstructured{}
			got.SetGroupVersionKind(schema.GroupVersionKind{Group: "kuadrant.io", Version: "v1alpha1", Kind: "TokenRateLimitPolicy"})
			if err := c.Get(context.Background(), types.NamespacedName{Name: trlpName, Namespace: namespace}, got); err != nil {
				t.Fatalf("Get TokenRateLimitPolicy %q: %v", trlpName, err)
			}

			// The controller sets spec.targetRef.name to the HTTPRoute name on update.
			// A sentinel value means no update occurred.
			targetRefName, _, _ := unstructured.NestedString(got.Object, "spec", "targetRef", "name")
			specChanged := targetRefName != "sentinel-route"

			if specChanged != tc.wantSpecChanged {
				if tc.wantSpecChanged {
					t.Errorf("spec.targetRef.name = %q: expected controller to overwrite sentinel value %q", targetRefName, "sentinel-route")
				} else {
					t.Errorf("spec.targetRef.name = %q: expected controller to preserve sentinel value %q (managed=false opt-out)", targetRefName, "sentinel-route")
				}
			}
		})
	}
}

// TestMaaSSubscriptionReconciler_DeleteAnnotation verifies that the Reconcile deletion
// path respects the opt-out annotation: a TokenRateLimitPolicy with
// opendatahub.io/managed=false or maas.opendatahub.io/managed=false must not be
// deleted when the parent MaaSSubscription is removed.
func TestMaaSSubscriptionReconciler_DeleteAnnotation(t *testing.T) {
	const (
		modelName   = "llm"
		namespace   = "default"
		trlpName    = "maas-trlp-" + modelName
		maasSubName = "sub-a"
	)

	tests := []struct {
		name        string
		annotations map[string]string
		wantDeleted bool
	}{
		{
			name:        "annotation absent: controller deletes",
			annotations: map[string]string{},
			wantDeleted: true,
		},
		{
			name:        "managed=true (new annotation): controller deletes",
			annotations: map[string]string{ManagedByODHOperator: "true"},
			wantDeleted: true,
		},
		{
			name:        "managed=false (new annotation): controller must not delete",
			annotations: map[string]string{ManagedByODHOperator: "false"},
			wantDeleted: false,
		},
		{
			name:        "managed=true (legacy annotation): controller deletes",
			annotations: map[string]string{ManagedByMaasODHOperator: "true"},
			wantDeleted: true,
		},
		{
			name:        "managed=false (legacy annotation): controller must not delete",
			annotations: map[string]string{ManagedByMaasODHOperator: "false"},
			wantDeleted: false,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			existingTRLP := newPreexistingTRLP(trlpName, namespace, modelName, tc.annotations)

			// Create MaaSSubscription with finalizer so handleDeletion processes it.
			maasSub := &maasv1alpha1.MaaSSubscription{
				ObjectMeta: metav1.ObjectMeta{
					Name:       maasSubName,
					Namespace:  namespace,
					Finalizers: []string{maasSubscriptionFinalizer},
				},
				Spec: maasv1alpha1.MaaSSubscriptionSpec{
					Owner: maasv1alpha1.OwnerSpec{
						Groups: []maasv1alpha1.GroupReference{{Name: "team-a"}},
					},
					ModelRefs: []maasv1alpha1.ModelSubscriptionRef{
						{Name: modelName, TokenRateLimits: []maasv1alpha1.TokenRateLimit{{Limit: 100, Window: "1m"}}},
					},
				},
			}

			c := fake.NewClientBuilder().
				WithScheme(scheme).
				WithRESTMapper(trlpTestRESTMapper()).
				WithObjects(maasSub, existingTRLP).
				Build()

			// Simulate deletion: the fake client sets DeletionTimestamp while the
			// finalizer keeps the object in the store.
			if err := c.Delete(context.Background(), maasSub); err != nil {
				t.Fatalf("Delete MaaSSubscription: %v", err)
			}

			r := &MaaSSubscriptionReconciler{Client: c, Scheme: scheme}
			req := ctrl.Request{NamespacedName: types.NamespacedName{Name: maasSubName, Namespace: namespace}}
			if _, err := r.Reconcile(context.Background(), req); err != nil {
				t.Fatalf("Reconcile: unexpected error: %v", err)
			}

			got := &unstructured.Unstructured{}
			got.SetGroupVersionKind(schema.GroupVersionKind{Group: "kuadrant.io", Version: "v1alpha1", Kind: "TokenRateLimitPolicy"})
			err := c.Get(context.Background(), types.NamespacedName{Name: trlpName, Namespace: namespace}, got)

			if tc.wantDeleted {
				if !apierrors.IsNotFound(err) {
					t.Errorf("expected TokenRateLimitPolicy %q to be deleted, but it still exists", trlpName)
				}
			} else {
				if err != nil {
					t.Errorf("expected TokenRateLimitPolicy %q to survive deletion (managed=false opt-out), but got: %v", trlpName, err)
				}
			}
		})
	}
}
